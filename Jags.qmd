---
title: "Jags"
format: html
---
```{r}
# --- Libraries ---
library(R2jags)
library(coda)

# --- Prepare data ---
rootData$logLength <- log(rootData$Length)

# Make sure the indicator columns are numeric (0/1)
rootData$WT    <- as.numeric(rootData$WT)       # genotype indicator
rootData$outer <- as.numeric(rootData$outer)    # side indicator

# --- safe JAGS model file ---
cat("
model {
  for (i in 1:N) {
    logL[i] ~ dnorm(mu[i], tau)
    # Lmax for observation i (must be positive)
    Lmax_i[i] <- exp(logLmax0 + logLmax_gen * isMU[i] + logLmax_side * isOuter[i] + logLmax_int * isMU[i] * isOuter[i])

    # Lmin positive via exp()
    Lmin_pos <- exp(logLmin)

    # logistic-like inner expression; add tiny eps to avoid log(0) if numerical rounding occurs
    inner[i] <- Lmin_pos + ((Lmax_i[i] - Lmin_pos) / (1 + exp(-(Midline[i] - xmid)/s)))
    mu[i] <- log( inner[i] + 1e-8 )   # tiny epsilon to avoid exact 0
  }

  # Priors on log-scale keep positivity and help sampling stability
  logLmin     ~ dnorm(log(1), 1.0E-2)     # center near log(1); increase precision if you want narrower prior
  logLmax0    ~ dnorm(log(10), 1.0E-2)
  logLmax_gen ~ dnorm(0, 1.0E-2)
  logLmax_side~ dnorm(0, 1.0E-2)
  logLmax_int ~ dnorm(0, 1.0E-2)

  # Midpoint and slope (xmid can be any real; s must be positive)
  xmid ~ dnorm(0, 1.0E-4)
  s    ~ dgamma(2, 1)    # shape=2, rate=1 gives a reasonable positive scale

  # observation variance
  sigma ~ dunif(0, 20)
  tau <- pow(sigma, -2)
}
", file = "rootModel_safe.jags")

# --- JAGS data list ---
data_list <- list(
  N        = nrow(rootData),
  logL     = rootData$logLength,
  Midline  = rootData$Midline_s,
  isMU     = rootData$WT,
  isOuter  = rootData$outer
)

# --- Initial values ---
inits_fn <- function() {
  list(
    Lmin = runif(1, 1, 10),
    Lmax0 = runif(1, 5, 20),
    Lmax_gen = rnorm(1, 0, 1),
    Lmax_side = rnorm(1, 0, 1),
    Lmax_int = rnorm(1, 0, 1),
    xmid = rnorm(1, 0.25, 0.1),
    s = runif(1, 0.01, 1),
    sigma = runif(1, 0.1, 2)
  )
}

params <- c("Lmin","Lmax0","Lmax_gen","Lmax_side","Lmax_int","xmid","s","sigma")

# --- Run JAGS ---
jags_out <- jags(
  data = data_list,
  inits = inits_fn,
  parameters.to.save = params,
  model.file = "rootModel.jags",
  n.chains = 4,
  n.iter = 50000,
  n.burnin = 10000,
  n.thin = 2,
  DIC = FALSE
)

print(jags_out)
mcmc_chains <- as.mcmc(jags_out)

# --- Diagnostics like in your slides ---
gelman.plot(mcmc_chains)
gelman.diag(mcmc_chains)
effectiveSize(mcmc_chains)
raftery.diag(mcmc_chains)
autocorr.plot(mcmc_chains)
summary(mcmc_chains)
HPDinterval(mcmc_chains)

mcmc_chains
```

```{r}

# Convert JAGS output to mcmc.list (already done)
mcmc_chains <- as.mcmc(jags_out)

# --- Trace plots ---
# Trace plots for all monitored parameters
traceplot(mcmc_chains)

# If you want to plot a specific parameter, e.g., 'Lmin':
traceplot(mcmc_chains[, "Lmin"])

# You can also combine with density plots
densplot(mcmc_chains)


```

```{r}
# Trace plots for key parameters
library(coda)

# Plot all parameters together
traceplot(mcmc_chains)

# Example: sigma trace with posterior mean (red) and frequentist estimate (green)
sigma_post <- as.numeric(as.matrix(mcmc_chains)[, "sigma"])
plot(sigma_post, type="l", col="black", ylab="sigma", xlab="Iteration/10")
abline(h=mean(sigma_post), col="red", lwd=2)   # posterior mean
abline(h=sd(rootData$Length), col="green", lwd=2)  # frequentist reference

```
```{r}
# Convert MCMC output to a matrix
sims <- as.data.frame(as.matrix(mcmc_chains))

# Posterior histograms for fixed effects
par(mfrow=c(2, 3))
for (param in c("Lmax0", "Lmax_gen", "Lmax_side", "Lmax_int", "xmid", "s")) {
  hist(sims[[param]], freq=FALSE, breaks=50,
       main=paste("Posterior of", param), xlab=param, col="gray90", border="white")
  lines(density(sims[[param]]), col="blue", lwd=2)
  abline(v=mean(sims[[param]]), col="red", lwd=2)
}
par(mfrow=c(1,1))

```

```{r}
# --- Compute posterior summaries ---
posterior_summary <- function(varname) {
  x <- sims[[varname]]
  c(mean = mean(x),
    lower = quantile(x, 0.025),
    upper = quantile(x, 0.975))
}

# Apply to parameters
params_summary <- t(sapply(c("Lmax0", "Lmax_gen", "Lmax_side", "Lmax_int"), posterior_summary))
params_summary <- as.data.frame(params_summary)

# Add a column for parameter names (for ggplot)
params_summary$Parameter <- rownames(params_summary)

# --- Plot with error bars ---
library(ggplot2)

ggplot(params_summary, aes(x = Parameter, y = mean)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +
  theme_minimal() +
  labs(title = "Posterior Means and 95% Credible Intervals",
       x = "Parameter",
       y = "Estimate")


```

```{r}
# Posterior means for fitted values
fitted_mu <- colMeans(as.matrix(mcmc_chains)[, grep("^mu", colnames(as.matrix(mcmc_chains)))])
residuals <- rootData$logLength - fitted_mu

# QQ plot
qqnorm(residuals, main="Normal Q-Q Plot of Residuals")
qqline(residuals, col="red", lwd=2)

# Boxplot by side
boxplot(residuals ~ rootData$side, las=1,
        ylab="Residuals", xlab="Side", col="gray90")
abline(h=0, col="red", lwd=2)

# Boxplot by root (random effect group)
boxplot(residuals ~ rootData$root, las=1,
        ylab="Residuals", xlab="Root ID", col="gray90")
abline(h=0, col="red", lwd=2)

```
```{r}
# Example comparison of Lmax estimates
freq_estimates <- summary(fit_nls)$coefficients[c("Lmax0", "Lmax_gen", "Lmax_side", "Lmax_int"), 1]

params_summary$frequentist <- freq_estimates

ggplot(params_summary, aes(x=rownames(params_summary))) +
  geom_point(aes(y=mean), color="red", size=3) +
  geom_errorbar(aes(ymin=lower, ymax=upper), width=0.2, color="red") +
  geom_point(aes(y=frequentist), color="green", shape=17, size=3) +
  theme_minimal() +
  labs(title="Bayesian (red) vs Frequentist (green) Parameter Estimates",
       y="Estimate", x="Parameter")

```

```{r}
#| label: metrics_new

# Estimated effective sample sizes for all parameters
effectiveSize(mcmc_chains)

# Table for quick review
ESS_table <- data.frame(
  Parameter = colnames(as.matrix(mcmc_chains)),
  ESS = effectiveSize(mcmc_chains)
)
print(ESS_table)

library(dplyr)
library(ggplot2)

# Extract posterior draws
sims <- as.data.frame(as.matrix(mcmc_chains))

# Prediction grid of midline values
mid_grid <- seq(min(rootData$Midline_s), max(rootData$Midline_s), length.out = 200)

# Posterior predictions for WT=0 inner (as an example)
pred_list <- lapply(1:nrow(sims), function(i) {
  Lmax <- exp(sims$logLmax0[i])
  Lmin <- exp(sims$logLmin[i])
  xmid <- sims$xmid[i]
  s    <- sims$s[i]
  
  pred <- Lmin + (Lmax - Lmin) / (1 + exp(-(mid_grid - xmid)/s))
  return(pred)
})

pred_mat <- do.call(rbind, pred_list)

pred_df <- data.frame(
  mid = mid_grid,
  mean = apply(pred_mat, 2, mean),
  lo = apply(pred_mat, 2, quantile, 0.025),
  hi = apply(pred_mat, 2, quantile, 0.975)
)

ggplot(pred_df, aes(mid, mean)) +
  geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.2) +
  geom_line(size=1.2) +
  labs(title = "Posterior Audiogram Estimate (WT Inner)",
       x="Midline", y="Predicted Cell Length") +
  theme_minimal()

# Compute posterior mean prediction for each observation
pred_obs <- numeric(nrow(rootData))

for (i in 1:nrow(rootData)) {
  Lmax <- exp(sims$logLmax0) *
          exp(sims$logLmax_gen * rootData$WT[i]) *
          exp(sims$logLmax_side * rootData$outer[i]) *
          exp(sims$logLmax_int * rootData$WT[i] * rootData$outer[i])

  Lmin <- exp(sims$logLmin)
  xmid <- sims$xmid
  s <- sims$s

  mu_post <- Lmin + (Lmax - Lmin) / (1 + exp(-(rootData$Midline_s[i] - xmid)/s))
  pred_obs[i] <- mean(log(mu_post))
}

resids <- rootData$logLength - pred_obs

boxplot(resids, main="Residual Boxplot", ylab="Residuals")
abline(h = 0, col="red", lwd=2)

qqnorm(resids, main="Residual QQ Plot")
qqline(resids, col="red", lwd=2)

```

```{r}
# p2
sims <- as.data.frame(as.matrix(mcmc_chains))
library(ggplot2)

mid_grid <- seq(min(rootData$Midline_s), max(rootData$Midline_s), length.out = 200)

pred_mat <- sapply(1:nrow(sims), function(i) {
  Lmax <- exp(sims$logLmax0[i])
  Lmin <- exp(sims$logLmin[i])
  xmid <- sims$xmid[i]
  s    <- sims$s[i]

  Lmin + (Lmax - Lmin) / (1 + exp(-(mid_grid - xmid)/s))
})

pred_df <- data.frame(
  mid = mid_grid,
  mean = apply(pred_mat, 1, mean),
  lo = apply(pred_mat, 1, quantile, 0.025),
  hi = apply(pred_mat, 1, quantile, 0.975)
)

ggplot(pred_df, aes(mid, mean)) +
  geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.25) +
  geom_line(size = 1.2) +
  labs(title = "Posterior Logistic Growth Curve (WT Inner)",
       x = "Midline", y = "Predicted Length") +
  theme_minimal()
pred_obs <- numeric(nrow(rootData))

for (n in 1:nrow(rootData)) {
  Lmax <- exp(
    sims$logLmax0 +
    sims$logLmax_gen * rootData$WT[n] +
    sims$logLmax_side * rootData$outer[n] +
    sims$logLmax_int * rootData$WT[n] * rootData$outer[n]
  )

  Lmin <- exp(sims$logLmin)

  mu <- Lmin + (Lmax - Lmin) /
        (1 + exp(-(rootData$Midline_s[n] - sims$xmid) / sims$s))

  pred_obs[n] <- mean(log(mu))
}

resids <- rootData$logLength - pred_obs
boxplot(resids, main = "Residual Boxplot", ylab = "Residuals")
abline(h = 0, col = "red", lwd = 2)
qqnorm(resids, main="Residual QQ Plot")
qqline(resids, col="red", lwd=2)

```





